<!doctype html>
<html lang="en">
	<head>
		<meta charset="utf-8">
		<meta name="viewport" content="width=device-width, initial-scale=1">
		<title>Project BTC</title>
		<link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.8/dist/css/bootstrap.min.css" rel="stylesheet" integrity="sha384-sRIl4kxILFvY47J16cr9ZwB07vP4J8+LH7qKQnuqkuIAvNWLzeN8tE5YBujZqJLB" crossorigin="anonymous">
	</head>
	<body>
		<h1>BitTorrent Tracker Cache</h1>
		<p>This service provides a generic peer list cache, inspired by <a href="https://web.archive.org/web/20250919064703/https://blog.lyc8503.net/post/pt-hack">this blog post</a>. Some features:</p>
		<ul>
			<li><b>Automagical Caching: </b>Just change the tracker URL in your torrent file, and this service manages everything for you.</li>
			<li><b>Tracker Aggregation: </b>This service uses <tt>info_hash</tt> to distinguish different torrents. All known peers for a torrent are reported, even if they come from different trackers.</li>
			<li><b>TTL: </b>You could set a custom time-to-live for the cache. This service forces a re-announcement once the cache is expired.</li>
			<li><b>Arbitrary Client Support: </b>You can leech using any client you like. This service guarantees a fake qBittorrent instance is used for connecting to the actual tracker.</li>
			<li><b>Privacy: </b>You do not show your real IP address to the actual tracker when using this service. Also, this service does not store your information like IP and passkeys. If you do not trust it, you could deploy your own instance from <a href="https://github.com/arielherself/btc">the codebase</a>.</li>
			<li><b>AI Free: </b>All code except the button on this page is handcrafted, and does not utilize AI in any form. If you are a fan of language models, you could close this tab now.</li>
		</ul>

		<h2>Usage</h2>
		<p>Upload your torrent below, then download the modified one. After that, add the new torrent to your BitTorrent client and start leeching.</p>

		<!-- Start of AI-generated code -->
		<button id="uploadBtn">Upload a file</button>
		<input id="fileInput" type="file" hidden />
		<div id="status" aria-live="polite"></div>

		<script>
		const uploadBtn = document.getElementById('uploadBtn');
		const fileInput = document.getElementById('fileInput');
		const statusEl  = document.getElementById('status');

		uploadBtn.addEventListener('click', () => fileInput.click());

		fileInput.addEventListener('change', async () => {
			const file = fileInput.files[0];
			if (!file) return;

			statusEl.textContent = 'Uploadingâ€¦';
			const form = new FormData();
			form.append('file', file, file.name); // change field name if your API expects another

			try {
				const res = await fetch('https://tracker.submy.org/transform', {
					method: 'POST',
					body: form,
				});

				// If the server returned an error status, try to show the message
				if (!res.ok) {
					const ct = res.headers.get('content-type') || '';
					const errText = ct.includes('application/json') ? JSON.stringify(await res.json(), null, 2) : await res.text();
					throw new Error(errText || `HTTP ${res.status}`);
				}

				// Get filename from Content-Disposition if present; otherwise derive from original
				const cd = res.headers.get('content-disposition') || '';
				const filenameMatch = /filename\*=UTF-8''([^;]+)|filename="([^"]+)"|filename=([^;]+)/i.exec(cd);
				const serverFilename = filenameMatch
					? decodeURIComponent(filenameMatch[1] || filenameMatch[2] || filenameMatch[3])
					: inferOutputName(file.name, res.headers.get('content-type'));

				// Read as Blob and trigger a download
				const blob = await res.blob();
				const url = URL.createObjectURL(blob);
				const a = document.createElement('a');
				a.href = url;
				a.download = serverFilename || 'download';
				document.body.appendChild(a);
				a.click();
				a.remove();
				URL.revokeObjectURL(url);

				statusEl.textContent = `Done. Saved: ${a.download}`;
			} catch (err) {
				statusEl.textContent = 'Upload failed:\n' + (err?.message || String(err));
			} finally {
				fileInput.value = ''; // allow re-selecting same file
			}
		});

		// Helper: if no filename from headers, try to make a reasonable one
		function inferOutputName(inputName, contentType) {
			const dot = inputName.lastIndexOf('.');
			const base = dot > -1 ? inputName.slice(0, dot) : inputName;
			const extFromCT = contentTypeToExt(contentType);
			return `${base}.transformed${extFromCT ? '.' + extFromCT : ''}`;
		}

		function contentTypeToExt(ct = '') {
			// very small map; extend as needed
			ct = ct.toLowerCase();
			if (ct.includes('pdf')) return 'pdf';
			if (ct.includes('zip')) return 'zip';
			if (ct.includes('json')) return 'json';
			if (ct.includes('xml')) return 'xml';
			if (ct.includes('csv')) return 'csv';
			if (ct.includes('plain')) return 'txt';
			return ''; // unknown
		}
		</script>
		<!-- End of AI-generated code -->

		<h2>Disclaimer</h2>
		<ul>
			<li>Your account could be banned for using this service. DYOR.</li>
			<li>This project exists simply because I am boring. If you think it is unethical, you could close this tab. But if you like it, please consider <a href="https://github.com/arielherself/btc">giving it a star</a>.</li>
		</ul>
		<script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.8/dist/js/bootstrap.bundle.min.js" integrity="sha384-FKyoEForCGlyvwx9Hj09JcYn3nv7wiPVlz7YYwJrWVcXK/BmnVDxM+D2scQbITxI" crossorigin="anonymous"></script>
	</body>
</html>
